#ifndef SUIVEURNXC
#define SUIVEURNXC

/*
Capteur rouge :
50      -> 10
blanc   -> noir


*/

#include "suiveur.h"
#include "main.h"
#include "lib.h"

void suitLaLigneEnAvancant(int temps, int vitesse, bool droite = true) // à priori à droite de la ligne
{
    int tempsDepart = CurrentTick();
    int tempsPasse = 0;
    int valeurVisuel;

    /*Capteur rouge :
50      -> 10
blanc   -> noir
*/
    tourne(MOTEUR_DROIT, vitesse);
    tourne(MOTEUR_GAUCHE, vitesse);
    while(tempsPasse < temps)
    {
        afficheErreurInt(tempsPasse);
        valeurVisuel =  Sensor(CAPTEUR_VISUEL);
        int inutile;
        if(!determineVitesseMoteur(valeurVisuel, vitesse, droite, inutile, inutile))
            afficheErreur("perte de la ligne");
        // On recalcule le temps passé à chaque tour.
        tempsPasse = CurrentTick() - tempsDepart;
    }
    stopMoteur();

}
// permet de suivre une ligne pendant un certain nombre de tournant.
// Si il y a un obstacle, false est renvoyé et nbTournant vaut le nombre de tournant avant l'obstacle
bool suitLaLigneEnAvancantTournant(int& nbTournant, int vitesse, bool droite = true)
{
    int valeurVisuel;
    int tempsDepart = CurrentTick();
    int tempsPasse = 0;
    /*Capteur rouge :
50      -> 10
blanc   -> noir
*/
    int valeurUltra = SensorUS(CAPTEUR_ULTRA);

    int nbTournantActuel = 0;
    int depassementBlanc = 0;
    int depassementNoir = 0;
    tourne(MOTEUR_DROIT, vitesse);
    tourne(MOTEUR_GAUCHE, vitesse);
    while(nbTournantActuel != nbTournant && valeurUltra > DISTANCE_OBSTACLE)
    {
        afficheErreurInt(nbTournantActuel);
        valeurVisuel =  Sensor(CAPTEUR_VISUEL);

        if(!determineVitesseMoteur(valeurVisuel, vitesse, droite, depassementNoir, depassementBlanc))
            afficheErreur("perte de la ligne");
        // On recalcule le temps passé à chaque tour pour éviter de compter un tournant au démarrage.
        tempsPasse = CurrentTick() - tempsDepart;
        if(tempsPasse < 500)
        {
            depassementBlanc = 0;
            depassementNoir = 0;
        }
        // On recalcule le nombre de tournant à chaque tour.
        if(depassementBlanc == 4 || depassementNoir == 4)
            nbTournantActuel++;

        valeurUltra = SensorUS(CAPTEUR_ULTRA);

    }

    stopMoteur();
    if(nbTournantActuel == nbTournant)
    {
        suitLaLigneEnAvancant(200, vitesse, droite);
        return true;
    }
    else
    {
        nbTournant = nbTournantActuel;
        return false;
    }
}
// permet de suivre la ligne juqu'à une certaine distance d'un obstacle
void suitLaLigneEnAvancantDistance(int distance, int vitesse, bool droite = true) // à priori à droite de la ligne
{

    int valeurVisuel;
    int valeurUltra = SensorUS(CAPTEUR_ULTRA);
    /*Capteur rouge :
50      -> 10
blanc   -> noir
*/

    tourne(MOTEUR_DROIT, vitesse);
    tourne(MOTEUR_GAUCHE, vitesse);
    while(valeurUltra > distance)
    {
        afficheErreurInt(valeurUltra);
        valeurVisuel =  Sensor(CAPTEUR_VISUEL);
        int inutile;
        if(!determineVitesseMoteur(valeurVisuel, vitesse, droite, inutile, inutile))
            afficheErreur("perte de la ligne");
        // On récupère la distance actuelle à chaque tour
        valeurUltra = SensorUS(CAPTEUR_ULTRA);
    }
    stopMoteur();

}
// envoie aux moteurs les ordres nécessaires pour suivre la ligne. remonte les informations de dépassement via
// les variables depassementBlanc et depassementNoir
// Le fait de faire tourner les moteurs à l'envers si nécessaire permettra peut-être de suivre les
// lignes en marche arrière et améliore de toute facon le suivi.
// les commentaires sont écrits dans le cas droite = true
bool determineVitesseMoteur(int valeurVisuel, int vitesse, bool droite, int& depassementNoir, int& depassementBlanc)
{
    // valeurs à ajuster pour que le robot aille plus vite
    int valeurNoir = 0.5*(NOIR+BLANC) -5; // proche du noir
    int valeurBlanc = 0.5*(NOIR+BLANC) +5; // proche du blanc

    bool reponse = true;
    if(valeurVisuel <= valeurBlanc && valeurVisuel >= valeurNoir)
    {
        // On va à fond.
        tourne(MOTEUR_DROIT, vitesse);
        tourne(MOTEUR_GAUCHE, vitesse);
        depassementBlanc = 0;
        depassementNoir = 0;
    }
    else if (valeurVisuel < valeurNoir) // On est dans le noir , donc trop à gauche, le moteur droit ralentit
    {
        // On corrige proportionnellement.
        float coeff = (2*valeurVisuel - (valeurNoir+NOIR))/(valeurNoir - NOIR);
        // Le moteur n'avance pas entre -20 et 20, on n'utilise pas ces valeurs :
        coeff += signe(coeff)*0.25;
        coeff /= 1.25;
        if(droite)
        {
            tourne(MOTEUR_GAUCHE, vitesse);
            tourne(MOTEUR_DROIT, coeff * vitesse);
        }
        else
        {
            tourne(MOTEUR_DROIT, vitesse);
            tourne(MOTEUR_GAUCHE, coeff * vitesse);
        }
        depassementBlanc = 0;
        depassementNoir++;
    }
    else if (valeurVisuel > valeurBlanc) // On est dans le blanc, donc trop à droite, le moteur gauche ralentit
    {
        float coeff = (2*valeurVisuel - (valeurBlanc+BLANC))/(valeurBlanc - BLANC);
        // Le moteur n'avance pas entre -20 et 20, on n'utilise pas ces valeurs :
        coeff += signe(coeff)*0.25;
        coeff /= 1.25;

        if(droite)
        {
            tourne(MOTEUR_DROIT, vitesse);
            tourne(MOTEUR_GAUCHE, coeff * vitesse);
        }
        else
        {
            tourne(MOTEUR_GAUCHE, vitesse);
            tourne(MOTEUR_DROIT, coeff * vitesse);
        }
        depassementNoir = 0;
        depassementBlanc++;
    }
    if(valeurVisuel < (NOIR+2) || valeurVisuel > (BLANC-2))
            reponse = false;
    return reponse;

}
void suitLaLigneEnReculant(int temps, int vitesse, bool droite = true) // à droite de la ligne
{
    suitLaLigneEnAvancant(temps, -vitesse, droite);
}

// A ne pas utiliser si il n'y a pas de noir devant.
void avanceJusquANoir(int vitesse)
{
    avanceSynchro(vitesse);

    while(Sensor(CAPTEUR_VISUEL) > NOIR + 5)
        ;
    stopMoteur();
}
void reculeJusquANoir(int vitesse)
{
    reculeSynchro(vitesse);

    while(Sensor(CAPTEUR_VISUEL) > NOIR + 5)
        ;
    stopMoteur();
}
void avanceJusquAPasBlanc(int vitesse) // Rouge ou bleu
{
    avanceSynchro(vitesse);

    while(Sensor(CAPTEUR_VISUEL) > BLANC - 5)
        ;
    stopMoteur();
}
void avanceJusquABlanc(int vitesse)
{
    avanceSynchro(vitesse);

    while(Sensor(CAPTEUR_VISUEL) < BLANC - 10)
        ;
    stopMoteur();
}
void reculeJusquABlanc(int vitesse)
{
    reculeSynchro(vitesse);

    while(Sensor(CAPTEUR_VISUEL) < BLANC - 10)
        ;
    stopMoteur();
}
// A ne pas utiliser si on n'est pas près d'une ligne
void chercheLigne(int vitesse)
{
    demiTour(vitesse);
}
// A ne pas utiliser si on n'est pas sur une ligne
void demiTour(int vitesse)
{

    tourne(MOTEUR_DROIT, vitesse);
    tourne(MOTEUR_GAUCHE, -vitesse);

    while(Sensor(CAPTEUR_VISUEL) < BLANC -10)
        ;
    while(Sensor(CAPTEUR_VISUEL) > NOIR + 5)
        ;
    // A priori inutile.
    /*while(Sensor(CAPTEUR_VISUEL) < NOIR + 10)
        ;*/

    stopMoteur();

}
// sert à changer entre le suivi à gauche et le suivi à droite
// droite vaut true si on vient de droite et false si on vient de gauche.
void milieuLigne(bool droite)
{
    if(droite)
    {
        tourne(MOTEUR_DROIT, MAX);
        tourne(MOTEUR_GAUCHE, -MAX);
    }
    else
    {
        tourne(MOTEUR_GAUCHE, MAX);
        tourne(MOTEUR_DROIT, -MAX);
    }
    while(Sensor(CAPTEUR_VISUEL) > NOIR + 10)
        ;
}

#endif
